# ============================================================================
# Somnia JSON Extension
# Pure Somnia JSON serialization and deserialization
# ============================================================================

# ============================================================================
# JSON VALUE TYPES
# ============================================================================

class JsonValue {
    field type: string     # "string", "number", "bool", "null", "array", "object"
    field data: any
    
    method is_string() -> bool { return self.type == "string" }
    method is_number() -> bool { return self.type == "number" }
    method is_bool() -> bool { return self.type == "bool" }
    method is_null() -> bool { return self.type == "null" }
    method is_array() -> bool { return self.type == "array" }
    method is_object() -> bool { return self.type == "object" }
    
    method as_string() -> string {
        when self.type == "string" => return self.data
        return ""
    }
    
    method as_number() -> number {
        when self.type == "number" => return self.data
        return 0
    }
    
    method as_bool() -> bool {
        when self.type == "bool" => return self.data
        return false
    }
    
    method as_array() -> list {
        when self.type == "array" => return self.data
        return []
    }
    
    method as_object() -> map {
        when self.type == "object" => return self.data
        return {}
    }
    
    method get(key: string) -> JsonValue {
        when self.type == "object" => {
            when key in self.data => return self.data[key]
        }
        return json_null()
    }
    
    method at(index: number) -> JsonValue {
        when self.type == "array" => {
            when index >= 0 and index < len(self.data) => return self.data[index]
        }
        return json_null()
    }
}

# Factory functions for JsonValue
fun json_string(value: string) -> JsonValue {
    return JsonValue { type: "string", data: value }
}

fun json_number(value: number) -> JsonValue {
    return JsonValue { type: "number", data: value }
}

fun json_bool(value: bool) -> JsonValue {
    return JsonValue { type: "bool", data: value }
}

fun json_null() -> JsonValue {
    return JsonValue { type: "null", data: null }
}

fun json_array(items: list) -> JsonValue {
    return JsonValue { type: "array", data: items }
}

fun json_object(entries: map) -> JsonValue {
    return JsonValue { type: "object", data: entries }
}

# ============================================================================
# JSON PARSER
# ============================================================================

class JsonParser {
    field input: string
    field position: number
    field line: number
    field column: number
    
    method parse() -> JsonValue {
        self.skip_whitespace()
        return self.parse_value()
    }
    
    method parse_value() -> JsonValue {
        self.skip_whitespace()
        var char = self.peek()
        
        when char == "\"" => return self.parse_string()
        when char == "{" => return self.parse_object()
        when char == "[" => return self.parse_array()
        when char == "t" => return self.parse_true()
        when char == "f" => return self.parse_false()
        when char == "n" => return self.parse_null()
        when self.is_digit(char) or char == "-" => return self.parse_number()
        
        # Invalid JSON
        return json_null()
    }
    
    method parse_string() -> JsonValue {
        self.expect("\"")
        var result = ""
        
        while self.position < len(self.input) and self.peek() != "\"" {
            when self.peek() == "\\" => {
                self.advance()
                var escaped = self.peek()
                self.advance()
                
                when escaped == "n" => result = result + "\n"
                when escaped == "t" => result = result + "\t"
                when escaped == "r" => result = result + "\r"
                when escaped == "\"" => result = result + "\""
                when escaped == "\\" => result = result + "\\"
                when escaped == "/" => result = result + "/"
                when escaped == "b" => result = result + "\b"
                when escaped == "f" => result = result + "\f"
                when escaped == "u" => {
                    # Unicode escape - simplified
                    var hex = ""
                    for i in [0, 1, 2, 3] {
                        hex = hex + self.peek()
                        self.advance()
                    }
                    result = result + native_unicode(hex)
                }
                default => result = result + escaped
            }
            default => {
                result = result + self.peek()
                self.advance()
            }
        }
        
        self.expect("\"")
        return json_string(result)
    }
    
    method parse_number() -> JsonValue {
        var start = self.position
        
        # Negative sign
        when self.peek() == "-" => self.advance()
        
        # Integer part
        when self.peek() == "0" => {
            self.advance()
        }
        default => {
            while self.is_digit(self.peek()) {
                self.advance()
            }
        }
        
        # Decimal part
        when self.peek() == "." => {
            self.advance()
            while self.is_digit(self.peek()) {
                self.advance()
            }
        }
        
        # Exponent
        when self.peek() == "e" or self.peek() == "E" => {
            self.advance()
            when self.peek() == "+" or self.peek() == "-" => self.advance()
            while self.is_digit(self.peek()) {
                self.advance()
            }
        }
        
        var num_str = string_substring(self.input, start, self.position)
        var value = native_parse_number(num_str)
        return json_number(value)
    }
    
    method parse_object() -> JsonValue {
        self.expect("{")
        self.skip_whitespace()
        
        var entries = {}
        
        when self.peek() != "}" => {
            # Parse first entry
            var first = self.parse_object_entry()
            entries[first.key] = first.value
            
            # Parse remaining entries
            while self.peek() == "," {
                self.advance()
                self.skip_whitespace()
                var entry = self.parse_object_entry()
                entries[entry.key] = entry.value
            }
        }
        
        self.expect("}")
        return json_object(entries)
    }
    
    method parse_object_entry() -> map {
        self.skip_whitespace()
        var key_value = self.parse_string()
        var key = key_value.as_string()
        
        self.skip_whitespace()
        self.expect(":")
        self.skip_whitespace()
        
        var value = self.parse_value()
        self.skip_whitespace()
        
        return { "key": key, "value": value }
    }
    
    method parse_array() -> JsonValue {
        self.expect("[")
        self.skip_whitespace()
        
        var items = []
        
        when self.peek() != "]" => {
            # Parse first item
            items = items + [self.parse_value()]
            self.skip_whitespace()
            
            # Parse remaining items
            while self.peek() == "," {
                self.advance()
                self.skip_whitespace()
                items = items + [self.parse_value()]
                self.skip_whitespace()
            }
        }
        
        self.expect("]")
        return json_array(items)
    }
    
    method parse_true() -> JsonValue {
        self.expect_word("true")
        return json_bool(true)
    }
    
    method parse_false() -> JsonValue {
        self.expect_word("false")
        return json_bool(false)
    }
    
    method parse_null() -> JsonValue {
        self.expect_word("null")
        return json_null()
    }
    
    # Helper methods
    method peek() -> string {
        when self.position >= len(self.input) => return ""
        return string_substring(self.input, self.position, self.position + 1)
    }
    
    method advance() {
        when self.position < len(self.input) => {
            when self.peek() == "\n" => {
                self.line = self.line + 1
                self.column = 1
            }
            default => {
                self.column = self.column + 1
            }
            self.position = self.position + 1
        }
    }
    
    method expect(char: string) {
        when self.peek() == char => self.advance()
    }
    
    method expect_word(word: string) {
        for i in range(0, len(word)) {
            self.advance()
        }
    }
    
    method skip_whitespace() {
        while self.position < len(self.input) {
            var char = self.peek()
            when char == " " or char == "\t" or char == "\n" or char == "\r" => {
                self.advance()
            }
            default => break
        }
    }
    
    method is_digit(char: string) -> bool {
        return char >= "0" and char <= "9"
    }
}

# ============================================================================
# JSON SERIALIZER
# ============================================================================

class JsonSerializer {
    field indent: bool
    field indent_size: number
    field current_indent: number
    
    method serialize(value: JsonValue) -> string {
        return self.serialize_value(value)
    }
    
    method serialize_value(value: JsonValue) -> string {
        when value.type == "string" => return self.serialize_string(value.data)
        when value.type == "number" => return self.serialize_number(value.data)
        when value.type == "bool" => return if value.data then "true" else "false"
        when value.type == "null" => return "null"
        when value.type == "array" => return self.serialize_array(value.data)
        when value.type == "object" => return self.serialize_object(value.data)
        return "null"
    }
    
    method serialize_string(value: string) -> string {
        var result = "\""
        
        for i in range(0, len(value)) {
            var char = string_substring(value, i, i + 1)
            
            when char == "\"" => result = result + "\\\""
            when char == "\\" => result = result + "\\\\"
            when char == "\n" => result = result + "\\n"
            when char == "\r" => result = result + "\\r"
            when char == "\t" => result = result + "\\t"
            default => result = result + char
        }
        
        return result + "\""
    }
    
    method serialize_number(value: number) -> string {
        return native_to_string(value)
    }
    
    method serialize_array(items: list) -> string {
        when len(items) == 0 => return "[]"
        
        var result = "["
        var first = true
        
        when self.indent => {
            self.current_indent = self.current_indent + 1
            result = result + "\n"
        }
        
        for item in items {
            when not first => {
                result = result + ","
                when self.indent => result = result + "\n"
            }
            first = false
            
            when self.indent => result = result + self.get_indent()
            result = result + self.serialize_value(item)
        }
        
        when self.indent => {
            self.current_indent = self.current_indent - 1
            result = result + "\n" + self.get_indent()
        }
        
        return result + "]"
    }
    
    method serialize_object(entries: map) -> string {
        var keys = native_keys(entries)
        when len(keys) == 0 => return "{}"
        
        var result = "{"
        var first = true
        
        when self.indent => {
            self.current_indent = self.current_indent + 1
            result = result + "\n"
        }
        
        for key in keys {
            when not first => {
                result = result + ","
                when self.indent => result = result + "\n"
            }
            first = false
            
            when self.indent => result = result + self.get_indent()
            result = result + self.serialize_string(key) + ":"
            when self.indent => result = result + " "
            result = result + self.serialize_value(entries[key])
        }
        
        when self.indent => {
            self.current_indent = self.current_indent - 1
            result = result + "\n" + self.get_indent()
        }
        
        return result + "}"
    }
    
    method get_indent() -> string {
        var result = ""
        for i in range(0, self.current_indent * self.indent_size) {
            result = result + " "
        }
        return result
    }
}

# ============================================================================
# PUBLIC API
# ============================================================================

fun json_parse(input: string) -> JsonValue {
    var parser = JsonParser { 
        input: input, 
        position: 0, 
        line: 1, 
        column: 1 
    }
    return parser.parse()
}

fun json_stringify(value: JsonValue) -> string {
    var serializer = JsonSerializer { 
        indent: false, 
        indent_size: 2, 
        current_indent: 0 
    }
    return serializer.serialize(value)
}

fun json_stringify_pretty(value: JsonValue) -> string {
    var serializer = JsonSerializer { 
        indent: true, 
        indent_size: 2, 
        current_indent: 0 
    }
    return serializer.serialize(value)
}

# Convenience function to convert any value to JsonValue
fun to_json(value: any) -> JsonValue {
    var t = native_type(value)
    
    when t == "string" => return json_string(value)
    when t == "number" => return json_number(value)
    when t == "bool" => return json_bool(value)
    when t == "null" => return json_null()
    when t == "list" => {
        var items = []
        for item in value {
            items = items + [to_json(item)]
        }
        return json_array(items)
    }
    when t == "map" => {
        var entries = {}
        for key in native_keys(value) {
            entries[key] = to_json(value[key])
        }
        return json_object(entries)
    }
    
    return json_null()
}

# Convert JsonValue to native value
fun from_json(value: JsonValue) -> any {
    when value.type == "string" => return value.data
    when value.type == "number" => return value.data
    when value.type == "bool" => return value.data
    when value.type == "null" => return null
    when value.type == "array" => {
        var items = []
        for item in value.data {
            items = items + [from_json(item)]
        }
        return items
    }
    when value.type == "object" => {
        var result = {}
        for key in native_keys(value.data) {
            result[key] = from_json(value.data[key])
        }
        return result
    }
    
    return null
}

# ============================================================================
# EXPORTS
# ============================================================================

export {
    JsonValue,
    JsonParser,
    JsonSerializer,
    json_string,
    json_number,
    json_bool,
    json_null,
    json_array,
    json_object,
    json_parse,
    json_stringify,
    json_stringify_pretty,
    to_json,
    from_json
}
