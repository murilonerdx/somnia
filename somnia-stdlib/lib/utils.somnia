# ============================================================================
# Somnia Standard Library - Utilities
# UUID, random, datetime, and more
# ============================================================================

# ============================================================================
# UUID GENERATION
# ============================================================================

fun uuid() -> string {
    return uuid_v4()
}

fun uuid_v4() -> string {
    var hex_chars = "0123456789abcdef"
    var result = ""
    
    for i in range(0, 36) {
        when i == 8 or i == 13 or i == 18 or i == 23 => {
            result = result + "-"
        }
        when i == 14 => {
            result = result + "4"  # Version 4
        }
        when i == 19 => {
            var rand = math_floor(math_random() * 4) + 8
            result = result + string_substring(hex_chars, rand, rand + 1)
        }
        default => {
            var rand = math_floor(math_random() * 16)
            result = result + string_substring(hex_chars, rand, rand + 1)
        }
    }
    
    return result
}

fun short_id() -> string {
    var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    var result = ""
    
    for i in range(0, 8) {
        var rand = math_floor(math_random() * len(chars))
        result = result + string_substring(chars, rand, rand + 1)
    }
    
    return result
}

# ============================================================================
# DATETIME
# ============================================================================

class DateTime {
    field timestamp: number
    field year: number
    field month: number
    field day: number
    field hour: number
    field minute: number
    field second: number
    
    method to_iso_string() -> string {
        return native_to_string(self.year) + "-" +
               pad_number(self.month, 2) + "-" +
               pad_number(self.day, 2) + "T" +
               pad_number(self.hour, 2) + ":" +
               pad_number(self.minute, 2) + ":" +
               pad_number(self.second, 2) + "Z"
    }
    
    method to_date_string() -> string {
        return native_to_string(self.year) + "-" +
               pad_number(self.month, 2) + "-" +
               pad_number(self.day, 2)
    }
    
    method to_time_string() -> string {
        return pad_number(self.hour, 2) + ":" +
               pad_number(self.minute, 2) + ":" +
               pad_number(self.second, 2)
    }
    
    method add_days(days: number) -> DateTime {
        return from_timestamp(self.timestamp + days * 86400000)
    }
    
    method add_hours(hours: number) -> DateTime {
        return from_timestamp(self.timestamp + hours * 3600000)
    }
    
    method add_minutes(minutes: number) -> DateTime {
        return from_timestamp(self.timestamp + minutes * 60000)
    }
}

fun pad_number(n: number, width: number) -> string {
    var str = native_to_string(math_floor(n))
    while len(str) < width {
        str = "0" + str
    }
    return str
}

fun now() -> DateTime {
    var ts = native_time_ms()
    return from_timestamp(ts)
}

fun from_timestamp(ts: number) -> DateTime {
    var date_info = native_parse_timestamp(ts)
    return DateTime {
        timestamp: ts,
        year: date_info["year"],
        month: date_info["month"],
        day: date_info["day"],
        hour: date_info["hour"],
        minute: date_info["minute"],
        second: date_info["second"]
    }
}

fun parse_date(str: string) -> DateTime {
    var parts = string_split(str, "-")
    return DateTime {
        timestamp: 0,
        year: native_parse_number(parts[0]),
        month: native_parse_number(parts[1]),
        day: native_parse_number(parts[2]),
        hour: 0,
        minute: 0,
        second: 0
    }
}

# ============================================================================
# RANDOM
# ============================================================================

fun random_int(min: number, max: number) -> number {
    return math_floor(math_random() * (max - min + 1)) + min
}

fun random_float(min: number, max: number) -> number {
    return math_random() * (max - min) + min
}

fun random_choice(items: list) -> any {
    var index = random_int(0, len(items) - 1)
    return items[index]
}

fun shuffle(items: list) -> list {
    var result = []
    for item in items {
        result = result + [item]
    }
    
    for i in range(len(result) - 1, 0, -1) {
        var j = random_int(0, i)
        var temp = result[i]
        result[i] = result[j]
        result[j] = temp
    }
    
    return result
}

# ============================================================================
# RESULT TYPE (Error Handling)
# ============================================================================

class Result {
    field success: bool
    field value: any
    field error: string
    
    method is_ok() -> bool {
        return self.success
    }
    
    method is_err() -> bool {
        return not self.success
    }
    
    method unwrap() -> any {
        when not self.success => {
            println("[ERROR] Unwrap called on error result: " + self.error)
            return null
        }
        return self.value
    }
    
    method unwrap_or(default_val: any) -> any {
        when not self.success => return default_val
        return self.value
    }
    
    method map(fn: fun) -> Result {
        when not self.success => return self
        return ok(fn(self.value))
    }
    
    method flat_map(fn: fun) -> Result {
        when not self.success => return self
        return fn(self.value)
    }
}

fun ok(value: any) -> Result {
    return Result { success: true, value: value, error: "" }
}

fun err(message: string) -> Result {
    return Result { success: false, value: null, error: message }
}

# ============================================================================
# OPTION TYPE (Optional Values)
# ============================================================================

class Option {
    field has_value: bool
    field value: any
    
    method is_some() -> bool {
        return self.has_value
    }
    
    method is_none() -> bool {
        return not self.has_value
    }
    
    method unwrap() -> any {
        when not self.has_value => {
            println("[ERROR] Unwrap called on None")
            return null
        }
        return self.value
    }
    
    method unwrap_or(default_val: any) -> any {
        when not self.has_value => return default_val
        return self.value
    }
    
    method map(fn: fun) -> Option {
        when not self.has_value => return none()
        return some(fn(self.value))
    }
}

fun some(value: any) -> Option {
    return Option { has_value: true, value: value }
}

fun none() -> Option {
    return Option { has_value: false, value: null }
}

# ============================================================================
# EXPORTS
# ============================================================================

export {
    uuid, uuid_v4, short_id,
    DateTime, now, from_timestamp, parse_date,
    random_int, random_float, random_choice, shuffle,
    Result, ok, err,
    Option, some, none
}
