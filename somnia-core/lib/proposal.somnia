# ============================================================================
# Somnia Core Library - Proposal
# Self-hosted proposal types for the ID engine
# ============================================================================

import "types.somnia"

# ============================================================================
# PROPOSAL - Candidate action generated by ID
# ============================================================================

class Proposal {
    field action: string        # Action name to execute
    field args: map             # Action arguments
    field weight: number        # 0.0 to 1.0
    field rule_id: string       # Which rule generated this
    field rule_line: number     # Source line
    field explanation: string   # Why this was proposed
    
    method with_weight(new_weight: number) -> Proposal {
        return Proposal {
            action: self.action,
            args: self.args,
            weight: clamp(new_weight, 0.0, 1.0),
            rule_id: self.rule_id,
            rule_line: self.rule_line,
            explanation: self.explanation
        }
    }
    
    method with_explanation(text: string) -> Proposal {
        return Proposal {
            action: self.action,
            args: self.args,
            weight: self.weight,
            rule_id: self.rule_id,
            rule_line: self.rule_line,
            explanation: text
        }
    }
    
    method to_string() -> string {
        return "Proposal(" + self.action + " @" + native_to_string(self.weight) + ")"
    }
}

fun create_proposal(action: string, args: map, weight: number, rule_id: string, line: number) -> Proposal {
    return Proposal {
        action: action,
        args: args,
        weight: clamp(weight, 0.0, 1.0),
        rule_id: rule_id,
        rule_line: line,
        explanation: ""
    }
}

# ============================================================================
# PROPOSAL LIST - Collection of proposals with sorting
# ============================================================================

class ProposalList {
    field items: list
    
    method add(proposal: Proposal) {
        self.items = self.items + [proposal]
    }
    
    method count() -> number {
        return len(self.items)
    }
    
    method is_empty() -> bool {
        return len(self.items) == 0
    }
    
    method get(index: number) -> Proposal {
        return self.items[index]
    }
    
    method sort_by_weight() {
        # Sort descending by weight
        self.items = native_sort(self.items, fun(a, b) {
            return b.weight - a.weight
        })
    }
    
    method top(n: number) -> ProposalList {
        var result = create_proposal_list()
        var count = min(n, len(self.items))
        
        for i in range(0, count) {
            result.add(self.items[i])
        }
        
        return result
    }
    
    method filter(predicate: fun) -> ProposalList {
        var result = create_proposal_list()
        
        for proposal in self.items {
            when predicate(proposal) => result.add(proposal)
        }
        
        return result
    }
    
    method to_list() -> list {
        return self.items
    }
}

fun create_proposal_list() -> ProposalList {
    return ProposalList { items: [] }
}

fun proposal_list_from(items: list) -> ProposalList {
    return ProposalList { items: items }
}

# ============================================================================
# SELECTED PROPOSAL - After EGO selection
# ============================================================================

class SelectedProposal {
    field proposal: Proposal
    field rank: number
    field reason: string
}

fun create_selected(proposal: Proposal, rank: number, reason: string) -> SelectedProposal {
    return SelectedProposal {
        proposal: proposal,
        rank: rank,
        reason: reason
    }
}

# ============================================================================
# REJECTED PROPOSAL - Filtered by EGO
# ============================================================================

class RejectedProposal {
    field proposal: Proposal
    field reason: string
    field policy_id: string
}

fun create_rejected(proposal: Proposal, reason: string, policy_id: string) -> RejectedProposal {
    return RejectedProposal {
        proposal: proposal,
        reason: reason,
        policy_id: policy_id
    }
}

# ============================================================================
# SELECTION RESULT - Output of EGO
# ============================================================================

class SelectionResult {
    field selected: list        # List of SelectedProposal
    field rejected: list        # List of RejectedProposal
    
    method selected_count() -> number {
        return len(self.selected)
    }
    
    method rejected_count() -> number {
        return len(self.rejected)
    }
    
    method first_selected() -> SelectedProposal {
        when len(self.selected) > 0 => return self.selected[0]
        return null
    }
}

fun create_selection_result() -> SelectionResult {
    return SelectionResult {
        selected: [],
        rejected: []
    }
}

# ============================================================================
# TESTS
# ============================================================================

test "Proposal creation" {
    var p = create_proposal("log", { "message": "hello" }, 0.9, "rule_1", 10)
    
    assert p.action == "log"
    assert p.weight == 0.9
    assert p.rule_id == "rule_1"
    assert p.rule_line == 10
}

test "Proposal weight clamping" {
    var p1 = create_proposal("test", {}, 1.5, "r1", 1)
    assert p1.weight == 1.0
    
    var p2 = create_proposal("test", {}, -0.5, "r1", 1)
    assert p2.weight == 0.0
}

test "Proposal with_weight" {
    var p = create_proposal("test", {}, 0.5, "r1", 1)
    var p2 = p.with_weight(0.8)
    
    assert p.weight == 0.5     # Original unchanged
    assert p2.weight == 0.8    # New has updated weight
}

test "ProposalList operations" {
    var list = create_proposal_list()
    
    assert list.is_empty() == true
    
    list.add(create_proposal("a", {}, 0.5, "r1", 1))
    list.add(create_proposal("b", {}, 0.9, "r2", 2))
    list.add(create_proposal("c", {}, 0.3, "r3", 3))
    
    assert list.count() == 3
    assert list.is_empty() == false
}

test "ProposalList sorting" {
    var list = create_proposal_list()
    list.add(create_proposal("low", {}, 0.3, "r1", 1))
    list.add(create_proposal("high", {}, 0.9, "r2", 2))
    list.add(create_proposal("mid", {}, 0.6, "r3", 3))
    
    list.sort_by_weight()
    
    assert list.get(0).action == "high"
    assert list.get(1).action == "mid"
    assert list.get(2).action == "low"
}

test "ProposalList top" {
    var list = create_proposal_list()
    list.add(create_proposal("a", {}, 0.9, "r1", 1))
    list.add(create_proposal("b", {}, 0.8, "r2", 2))
    list.add(create_proposal("c", {}, 0.7, "r3", 3))
    
    var top2 = list.top(2)
    assert top2.count() == 2
    assert top2.get(0).action == "a"
    assert top2.get(1).action == "b"
}

test "ProposalList filter" {
    var list = create_proposal_list()
    list.add(create_proposal("allow_1", {}, 0.9, "r1", 1))
    list.add(create_proposal("block_1", {}, 0.8, "r2", 2))
    list.add(create_proposal("allow_2", {}, 0.7, "r3", 3))
    
    var allowed = list.filter(fun(p) {
        return p.action.starts_with("allow")
    })
    
    assert allowed.count() == 2
}

test "SelectionResult" {
    var result = create_selection_result()
    
    assert result.selected_count() == 0
    assert result.rejected_count() == 0
    assert result.first_selected() == null
}
